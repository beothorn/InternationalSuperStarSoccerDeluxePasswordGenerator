<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>International Superstar Soccer Deluxe Password Generator</title>
</head>

<body>
    <style>
        body {
            font-family: "Courier New", Courier, monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: radial-gradient(circle at top, #1a1fbf 0%, #060069 55%, #040047 100%);
            color: #f4f1ff;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffffa0;
            text-shadow: 0 2px 0 #001cf8;
        }

        div {
            margin-bottom: 20px;
            width: 90%;
            max-width: 600px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #f4f1ff;
        }

        textarea {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border-radius: 8px;
            border: 2px solid #001cf8;
            background-color: #0d0b7a;
            color: #ffffd1;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 999px;
            border: 2px solid #ffa800;
            background: #0d0b7a;
            color: #ffffa0;
            font-weight: bold;
            box-shadow: 0 0 0 2px #001cf8;
        }

        #passwordIssues {
            color: #ff7a7a;
            font-weight: bold;
        }

        #passwordTypeSelector {
            width: 90%;
            max-width: 600px;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #001cf8;
            background-color: #0d0b7a;
            color: #ffffd1;
	        margin: 10px;
        }

        #generatedPasswordContainer {
            width: 90%;
            max-width: 600px;
        }

        #generatedPassword {
            white-space: pre-line;
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            color: #ffffff;
            background-color: #060069;
            border: 2px solid #ffffa0;
            border-radius: 14px;
            padding: 16px;
            -webkit-text-stroke: 1px #001cf8;
            text-shadow: 0 2px 0 #001cf8;
            box-shadow: 0 0 0 3px #ffa800, 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        #advancedSection {
            display: none;
        }

        #advancedSection.is-visible {
            display: block;
        }

        #advancedToggle {
            margin-top: 10px;
        }

        /* layout: label text on the left, input/select aligned in a fixed-size column on the right */
        #passwordParametersForm label {
            display: flex;
            align-items: center;
            justify-content: space-between; /* push input to the far right so all inputs line up */
            gap: 12px; /* small space between label text and input column */
        }

        #big-title {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            color: #ffffa0;
            text-shadow: 0 2px 0 #001cf8;
        }

        /* fixed width for inputs/selects (adjust width if you want more space for long names) */
        #passwordParametersForm label input,
        #passwordParametersForm label select {
            width: 220px;         /* fixed size to comfortably fit longest team name + padding */
            max-width: 100%;     /* won't overflow on very small screens */
            box-sizing: border-box;
            text-align: left;    /* keep text inside input/select left-aligned */
            flex: 0 0 220px;     /* don't grow or shrink, keep fixed column width */
            padding: 6px 8px;
            border-radius: 6px;
            border: 2px solid #001cf8;
            background-color: #0d0b7a;
            color: #ffffd1;
        }

        @media (max-width: 546px) {
            #generatedPassword {
                font-size: 1.2em;
            }
        }
    </style>
    <h1 id="big-title">International Superstar Soccer Deluxe Password Generator</h1>

    <select id="passwordTypeSelector"></select>
    <div id="passwordParametersForm"></div>
    <button onclick="generateInternationalEliminationPhasePassword()">Generate Password</button>
    <div id="generatedPasswordContainer">
        <p id="generatedPassword">••••• ••••• ••••• •••••
••••• ••••• ••••• •••••
••••• ••••• ••••• •••••</p>
    </div>
    <button id="advancedToggle" type="button" aria-expanded="false">Show advanced</button>

    <div id="advancedSection">
        <label for="password">Password: (size <span id="passSize">0</span>)</label>
        <textarea id="password" rows="4" cols="50" oninput="convertToDecoded()">S*2nT 513</textarea>
        <div>
            <label for="decodedPassword">Decoded Password: (size <span id="decodeSize">0</span>)</label>
            <textarea id="decodedPassword" rows="4"
                cols="50" oninput="updateSizeLabels()"></textarea>
        </div>
        <div>
            <div>
                <button onclick="convertToDecoded()">Convert Password to Decoded and check validity</button>
                <button onclick="convertToPassword()">Convert Decoded to Password</button>
                <p id="passwordIssues"></p>
                <p>
                    <h2>Main flags (in order, if one matches no other does):</h2>
                    <label><input type="checkbox" checked id="bit5" onchange="toggleBit(0x20, this.checked)"> Set bit 5 (#$0020) (world series?)</label>
                    <label><input type="checkbox" id="bit3" onchange="toggleBit(0x04, this.checked)"> Set bit 3 (#$0004) (International?)</label>
                    <label><input type="checkbox" id="bit2" onchange="toggleBit(0x02, this.c    hecked)"> Set bit 2 (#$0002) (Short league?)</label>
                    <label><input type="checkbox" id="bit11" onchange="toggleBit(0x0400, this.checked)"> Set bit 11 (#$0400) (Short tournament?)</label>
                    <label><input type="checkbox" id="bit13" onchange="toggleBit(0x1000, this.checked)"> Set bit 9 (#$1000)(Scenario?)</label>
                </p>

                <p>
                    <h2>Flags for bit 5 (in order, if one matches no other does):</h2>
                    <label><input type="checkbox" checked id="bit8" onchange="toggleBit(0x80, this.checked)"> Set bit 8 (#$0080)</label>
                    <label><input type="checkbox" id="bit9" onchange="toggleBit(0x100, this.checked)"> Set bit 9 (#$0100)</label>
                </p>

                <p>
                    <h2>Flags for bit 3 (in order, if one matches no other does):</h2>
                    <label><input type="checkbox" checked id="bit4" onchange="toggleBit(0x0008, this.checked)"> Set bit 4 (#$0008)(International Tournament?)</label>
                    <label><input type="checkbox" id="bit10" onchange="toggleBit(0x200, this.checked)"> Set bit 10 (#$0200)</label>
                </p>
            </div>
            <p>This is a work in progress. You probably will want to play around the decoded values and then convert them to a password.</p> 
                <ul>
                    <li>You can type <strong>(division)</strong> to use the symbol ÷</li>
                    <li>You can type <strong>(pi)</strong> to use the symbol π</li>
                    <li>You can type <strong>(arrowDown)</strong> to use the symbol ↓</li>
                    <li>You can type <strong>(arrowUp)</strong> to use the symbol ↑</li>
                    <li>You can type <strong>(note)</strong> to use the symbol ♪</li>
                    <li>You can type <strong>(star)</strong> to use the symbol ★</li>
                    <li>You can type <strong>(spades)</strong> to use the symbol ♠</li>
                    <li>You can type <strong>(diamonds)</strong> to use the symbol ♦</li>
                    <li>You can type <strong>(clubs)</strong> to use the symbol ♣</li>
                    <li>You can type <strong>(hearts)</strong> to use the symbol ♥</li>
                </ul>
        </div>
    </div>
    <script src="constants.js"></script>
    <script src="passwords.js"></script>
    <script src="passwordLogic.js"></script>
    <script src="tests.js"></script>
    <script>

 
        function populateTeamSelect(select) {
            teams.forEach(team => {
                const option = document.createElement("option");
                option.value = team.value;
                option.textContent = team.label;
                select.appendChild(option);
            });
        }

        function populateVictorySelect(select) {
            victoryStates.forEach(victory => {
                const option = document.createElement("option");
                option.value = victory.value;
                option.textContent = victory.label;
                select.appendChild(option);
            });
        }

        // Takes a password string and converts it to a decoded array
        // can include spaces, they will be ignored
        function passwordStringTo8bitArray(passwordString) {
            // Remove spaces and split by special character markers
            const parts = passwordString.replace(/\s+/g, '').split(/[()]/);
            let passAsEightBitArray = [];

            for (const part of parts) {
                if (specialChars[part] !== undefined) {
                    // If part is a special character, get its value from specialChars
                    passAsEightBitArray.push(specialChars[part]);
                } else {
                    // Otherwise, map each character to its index in chars
                    for (const char of part) {
                        const index = chars.indexOf(char);
                        if (index === -1) {
                            passAsEightBitArray.push(specialChars[char]);
                        } else {
                            passAsEightBitArray.push(index);
                        }
                    }
                }
            }
            // Add the final value of 255
            passAsEightBitArray.push(255);
            return passAsEightBitArray;
        }

        function toHex(value) {
            return "0x" + ('0' + value.toString(16)).slice(-2);
        }


        function printMemory(memory) {
            let memoryAsString = "";
            for (let i = 0; i < memory.length; i++) {
                if (memory[i]) {
                    memoryAsString += ('0' + memory[i].toString(16)).slice(-2) + " ";
                }
            }
            console.log("Current memory " + memoryAsString);
        }


        function printMemoryBinary(memory) {
            let memoryAsString = "";
            for (let i = 0; i < memory.length; i++) {
                if (memory[i]) {
                    memoryAsString += ('0' + memory[i].toString(2)).slice(-8) + " ";
                }
            }
            console.log("Current memory " + memoryAsString);
        }

        function printBinaryLE(value) {
            // Ensure the value is represented as a 16-bit binary number
            let binary = value.toString(2).padStart(16, '0');

            // Split the binary into two 8-bit parts for little-endian representation
            let lowByte = binary.slice(8, 16); // Lower 8 bits
            let highByte = binary.slice(0, 8); // Higher 8 bits

            // Combine in little-endian order
            binary = lowByte + " " + highByte + " - " + toHex(value & 0xFF) + " " + toHex((value >> 8) & 0xFF);

            return binary;
        }

        function printBinary(value) {
            // Ensure the value is represented as a 16-bit binary number
            let binary = value.toString(2).padStart(16, '0');

            // Split the binary into two 8-bit parts for little-endian representation
            let lowByte = binary.slice(8, 16); // Lower 8 bits
            let highByte = binary.slice(0, 8); // Higher 8 bits

            binary = highByte + " " + lowByte + " - " + toHex((value >> 8) & 0xFF) + " " + toHex(value & 0xFF);

            return binary;
        }

        // Given the password value array, returns the decoded password
        // a value array is the value from the characters, so for example
        // "BCD" is [1,2,3]
        // this function will return the decoded password, which will be used by ISSD to setup the game
        function getDecodedPasswordForPasswordValuesArray(passwordValues) {
            /*
            The loop increases multipleOfSixCounter by six on each pass
            From this we get the quotient and the remainder from a division by 8
            the quotient is the possition on the decoded password that will be changed
            and the remainder is the number of times we will rotate the bits
            since the position is a 8 bit value, and the value we are working with is 16 bit
            if the rotation results in a result that occupies more than 8 bits
            the next position will also be affected.
            This way there is a overlap and if a value is repeating, it is not that apparent
            The quotient also repeats due to the division, so it can also be that two values are 
            written to the same position (using bitwise OR)
            */
            let multipleOfSixCounter = 0;
            let passwordIndex = 0;
            let carry = 0;
            let result = [];
            do {
                const quotient = Math.floor(multipleOfSixCounter / 8); // it goes like 0 0 1 2 3 3 4 ...
                const remainder = multipleOfSixCounter % 8; // it goes like 0 6 4 2 0 6 4 2 repeating
                // so, for character 0 on password we shift the value 0 and apply to position 0
                // for character 1 we shift the value 1 right and 6 and apply to position 0
                // for character 3 we shift the value 1 right and 4 and apply to position 1
                // for character 4 we shift the value 1 right and 2 and apply to position 2
                let a = quotient; // A is the acumulator registry
                let y = remainder; // Y is another regiistry, used as index for memory accesses (X is anotehr one)
                let currentChar = passwordValues[passwordIndex];

                if (currentChar > biggestPossibleChar) { // string end marker is 0xff
                    break;
                }
                ({ newValue, newCarry } = ror(currentChar, carry)); // rotate right, don't know why
                a = newValue;
                carry = newCarry; // we need the carry to rotate, on the SNES cpu this is the flag C
                while (y >= 0) { // rotate left the number of times we got from the division remainder
                    ({ newValue, newCarry } = rol(a, carry));
                    a = newValue;
                    carry = newCarry;
                    y--;
                }
                a = a | readFromResultInMemory(result, quotient); // if there is already somethingn on the position, the result is the OR
                writeOnResultInMemory(result, quotient, a); // maybe A has values on the high part so we write it in a way the next position gets the high value 
                passwordIndex++; // next char from password
                multipleOfSixCounter += 6; // next 6 multiplier
            } while (multipleOfSixCounter < 360); // from the ISSD code, we know the password is 60 characters long
            return result;
        }


        function notEquals(a, b) {
            if (a.length != b.length) {
                return true;
            }
            for (let index = 0; index < a.length; index++) {
                if (a[index] !== b[index]) return true;
            }
            return false;
        }

        // Given a decodedPassword, returns a password string
        // This is a brute-force algorithm to find the password that returns the given decoded password
        // Luckly we can check each 8 bit entry to check if it is valid, so we brute-force it for each 16 bit entry
        // so it is not too expensive
        function genPassForDecodedPassword(decodedPassword) {
            let currentPassword = [0]; // initial guess
            let currentDecodedPasswordFromGuessedPassword = getDecodedPasswordForPasswordValuesArray(currentPassword.concat(0xff));

            let count = 0;
            while (notEquals(currentDecodedPasswordFromGuessedPassword, decodedPassword) || !(isValidPasswordValues(currentPassword.concat(0xff)).valid)) { // if the guess is not good, we keep iterating
                if (currentPassword.length > 71 || count++ > 30000 ) { // just a safeguard, max pass size (60) plus spaces plus 1
                    console.log("Could not find password");
                    console.log(currentPassword);
                    let memory = "";
                    for (let i = 0; i < currentDecodedPasswordFromGuessedPassword.length; i++) {
                        memory += toHex(currentDecodedPasswordFromGuessedPassword[i]) + " ";
                    }
                    console.log(memory);
                    memory = "";
                    for (let i = 0; i < currentPassword.length; i++) {
                        memory += currentPassword[i] + " ";
                    }
                    console.log(memory);
                    // throw error
                    throw new Error("Could not find password: "+isValidPasswordValues(currentPassword).reason);
                }
                let currentPasswordCharIndex = currentPassword.length - 1;
                let previousIndex = Math.floor(((currentPasswordCharIndex - 1) * 6) / 8);
                let currentIndex = Math.floor((currentPasswordCharIndex * 6) / 8);
                let nextIndex = Math.floor(((currentPasswordCharIndex + 1) * 6) / 8);

                if (currentDecodedPasswordFromGuessedPassword[currentIndex] === decodedPassword[currentIndex]) {
                    if (!notEquals(currentDecodedPasswordFromGuessedPassword, decodedPassword) && isValidPasswordValues(currentPassword).valid) {
                        break;
                    }
                    currentPassword = currentPassword.concat(0);
                } else {
                    let lastChar = currentPassword.pop();
                    let nextChar = lastChar + 1;
                    if (nextChar > biggestPossibleChar) {
                        // We need to know if next number may be able to fix value
                        // If yes, we go back to zero and continue
                        if (currentIndex === nextIndex) {
                            currentPassword = currentPassword.concat(0);
                            currentPassword = currentPassword.concat(0);
                        } else {
                            if (previousIndex === currentIndex) {
                                currentPassword[currentPassword.length - 1] = currentPassword[currentPassword.length - 1] + 1;
                                currentPassword = currentPassword.concat(0);
                            } else {
                                // lets hope the previous one will fix it
                                currentPassword[currentPassword.length - 1] = currentPassword[currentPassword.length - 1] + 1;
                            }
                        }
                    } else {
                        currentPassword = currentPassword.concat(nextChar);
                    }
                }

                currentDecodedPasswordFromGuessedPassword = getDecodedPasswordForPasswordValuesArray(currentPassword.concat(0xff));
            }
            return currentPassword;
        }

        function fixIssDeluxePasswordSimple(arr) {
            return fixChecksum(arr);
        }

        function getCountDownStartForDecoded(decoded) {
            if(isBitSet(decoded, 0x0020)) {
                if(!isBitSet(decoded, 0x0080) && !isBitSet(decoded, 0x0100)){
                    return 0x25;
                } else if(isBitSet(decoded, 0x0080)) {
                    return 0x08;
                } else  if(isBitSet(decoded, 0x0100)) {
                    return 0x06;
                }
            } else if(isBitSet(decoded, 0x0004)) { // Important note, if 0x20 is set, the other main bit is not checked, same for the other values
                if(!isBitSet(decoded, 0x0008) && !isBitSet(decoded, 0x0200)){
                    return 0x0b;
                } else if(isBitSet(decoded, 0x0008)) {
                    return 0x1d;
                } else  if(isBitSet(decoded, 0x0200)) {
                    return 0x09;
                }
            } else if(isBitSet(decoded, 0x0002)) {
                return 0x0f;
            } else if(isBitSet(decoded, 0x0400)) {
                return 0x12;
            } else if(isBitSet(decoded, 0x1000)) {
                return 0x14;
            } else {
                return 0;
            }
        }

        function fixChecksum(decoded) {

            const countDownStart = getCountDownStartForDecoded(decoded);

            let X = 2;
            let sum = 0;
            for(let i = countDownStart - 2; i > 0; i--) {
                sum += decoded[X];
                sum &= 0xFF;
                X++;
            }

            decoded[1] = ((sum + decoded[0]) & 0xFF);
            return decoded;
        }

        function badChecksum(decoded, countDownStart) {
            let X = 2;
            let sum = 0;
            for(let i = countDownStart - 2; i > 0; i--) {
                sum += decoded[X];
                sum &= 0xFF;
                X++;
            }

            const checkValue = decoded[1];
            if(checkValue != ((sum + decoded[0]) & 0xFF)) {
                console.log("Failed checksum");
                return true;
            } else {
                console.log("Good checksum");
                return false;
            }
        }

        function isValidPasswordValues(passwordArray) {
            const decoded = getDecodedPasswordForPasswordValuesArray(passwordArray.concat(0xff));

            if(isBitSet(decoded, 0x0020)) {
                if(!isBitSet(decoded, 0x0080) && !isBitSet(decoded, 0x0100)){
                    if (passwordArray.length - 1 != 50){
                        return {valid: false, reason: "With only flag 5 set, password size must be 50"};
                    } else  if (badChecksum(decoded, 0x25)) { // 0x25/37 comes from the game constants
                        return {valid: false, reason: "Bad checksum"};
                    }
                } else if(isBitSet(decoded, 0x0080)) {
                    if (passwordArray.length - 1 != 11){
                        return {valid: false, reason: "With flag 5 and 8 set, password size must be 11"};
                    } else if (badChecksum(decoded, 0x08)) { // 0x08/8 comes from the game constants
                        return {valid: false, reason: "Bad checksum"};
                    }
                } else  if(isBitSet(decoded, 0x0100)) {
                    if (passwordArray.length - 1 != 8){
                        return {valid: false, reason: "With flag 5 and 9 set, password size must be 8"};
                    } else  if (badChecksum(decoded, 0x06)) { // 0x06/6 comes from the game constants
                        return {valid: false, reason: "Bad checksum"};
                    }
                }
            } else if(isBitSet(decoded, 0x0004)) { // Important note, if 0x20 is set, the other main bit is not checked, same for the other values
                if(!isBitSet(decoded, 0x0008) && !isBitSet(decoded, 0x0200)){
                    if (passwordArray.length - 1 != 15){
                        return {valid: false, reason: "With only flag 3 set, password size must be 15"};
                    } else  if (badChecksum(decoded, 0x0b)) { // 0x0b/11 comes from the game constants
                        return {valid: false, reason: "Bad checksum"};
                    }
                } else if(isBitSet(decoded, 0x0008)) {
                    if (passwordArray.length - 1 != 39){
                        return {valid: false, reason: "With flag 3 and 4 set, password size must be 39"};
                    } else  if (badChecksum(decoded, 0x1d)) { // 0x1d/29 comes from the game constants
                        return {valid: false, reason: "Bad checksum"};
                    }
                } else  if(isBitSet(decoded, 0x0200)) {
                    if (passwordArray.length - 1 != 12){
                        return {valid: false, reason: "With flag 3 and 10 set, password size must be 12"};
                    } else  if (badChecksum(decoded, 0x09)) { // 0x09/09 comes from the game constants
                        return {valid: false, reason: "Bad checksum"};
                    }
                }
            } else if(isBitSet(decoded, 0x0002)) {
                if (passwordArray.length - 1 != 20){
                    return {valid: false, reason: "With flag 2, password size must be 20"};
                } else  if (badChecksum(decoded, 0x0f)) { // 0x0f/15 comes from the game constants
                    return {valid: false, reason: "Bad checksum"};
                }
            } else if(isBitSet(decoded, 0x0400)) {
                if (passwordArray.length - 1 != 24){
                    return {valid: false, reason: "With flag 11, password size must be 24"};
                } else  if (badChecksum(decoded, 0x12)) { // 0x12/18 comes from the game constants
                    return {valid: false, reason: "Bad checksum"};
                }
            } else if(isBitSet(decoded, 0x1000)) {
                if (passwordArray.length - 1 != 27){
                    return {valid: false, reason: "With flag 9, password size must be 27"};
                } else  if (badChecksum(decoded, 0x14)) { // 0x14/20 comes from the game constants
                    return {valid: false, reason: "Bad checksum"};
                }
            } else {
                return {valid: false, reason: "At least one of the main flags must be set."};
            }

            return {valid: true};
        }

        // Validates the first bit and the checksum
        function isValidPassword(password){   
            const passwordArray = passwordStringTo8bitArray(password);
            return isValidPasswordValues(passwordArray);
        }

        // UI -----
        function convertHexStringToArray(hexString) {
            // Remove the brackets and split the string by commas
            const hexArray = hexString.replace(/[\[\]]/g, '').split(', ');

            // Convert each hex value to a decimal number
            const decimalArray = hexArray.map(hex => parseInt(hex, 16));

            return decimalArray;
        }

        function setPasswordIssue(issue) {
            document.getElementById("passwordIssues").innerText = issue;
        }

        // Gets the decoded password and return a readable, usable ISSD password
        function convertToPassword() {
            setPasswordIssue("");
            const decodedPassword = document.getElementById("decodedPassword").value;
            const decodedPasswordArray = fixIssDeluxePasswordSimple(convertHexStringToArray(decodedPassword));
            // set password or message on error
            try {
                document.getElementById("password").value = encodedValuesToPasswordString(genPassForDecodedPassword(decodedPasswordArray));
                updateSizeLabels();
            } catch (e) {
                document.getElementById("password").value = e.message;
            }


            updateFlagCheckboxes();
            const isValid = isValidPassword(document.getElementById("password").value);
            if(!isValid.valid){
                setPasswordIssue(isValid.reason);
            }
        }

        function convertToDecoded() {
            setPasswordIssue("");

            const isValid = isValidPassword(document.getElementById("password").value);
            if(!isValid.valid){
                setPasswordIssue(isValid.reason);
            }
            const password = document.getElementById("password").value;
            const passwordArray = passwordStringTo8bitArray(password);
            const decoded = getDecodedPasswordForPasswordValuesArray(passwordArray.concat(0xff))
            let decodedResult = "[" + decoded.map(toHex).join(", ") + "]"; 
            document.getElementById("decodedPassword").value = decodedResult;
            updateSizeLabels();
            updateFlagCheckboxes();
        }

        function isBitSet(decodedPasswordArray, bitMask) {
            const lowMask = bitMask & 0xFF;
            const highMask = (bitMask >> 8) & 0xFF;

            // print 16 bits value in binary
            // console.log("Checking bit mask:\n0x" + bitMask.toString(16));
            // console.log("Checking bit mask:\n" + bitMask.toString(2).padStart(16, '0'));
            // console.log("decodedPasswordArray[2] ^ decodedPasswordArray[0]")
            // console.log(decodedPasswordArray[2].toString(2).padStart(16, '0'));
            // console.log(lowMask.toString(2).padStart(16, '0'));
            // console.log(((decodedPasswordArray[2] ^ decodedPasswordArray[0]) & lowMask).toString(2).padStart(16, '0'));
            // console.log("decodedPasswordArray[3] ^ decodedPasswordArray[0]")
            // console.log(decodedPasswordArray[3].toString(2).padStart(16, '0'));
            // console.log(highMask.toString(2).padStart(16, '0'));
            // console.log(((decodedPasswordArray[3] ^ decodedPasswordArray[0]) & highMask));

            if(
                ((decodedPasswordArray[2] ^ decodedPasswordArray[0]) & lowMask)
                || ((decodedPasswordArray[3] ^ decodedPasswordArray[0]) & highMask)
            ) {
                // console.log("bit is set");
                return true;
            }

            // console.log("bit is not set");
            return false;
        }

        // First and second bytes are XORed and are basically a lot of flags
        // position 2 is low and pos 3 is high
        function toggleBit(bitMask, bitShouldBeSet) {
            const decodedPasswordElement = document.getElementById("decodedPassword");
            const decodedPasswordArray = convertHexStringToArray(decodedPasswordElement.value);
            const lowMask = bitMask & 0xFF;
            const highMask = (bitMask >> 8) & 0xFF;
            
            
            if(lowMask){
                const bitIsSet = (decodedPasswordArray[2] ^ decodedPasswordArray[0]) & lowMask;
                if((bitIsSet && !bitShouldBeSet) || (!bitIsSet && bitShouldBeSet)){
                    // Flip bit at decodedPasswordArray[2]
                    console.log("Flipping bit pos 2 " + lowMask.toString(2));
                    console.log(decodedPasswordArray[2].toString(2));
                    decodedPasswordArray[2] ^= lowMask;
                    console.log(decodedPasswordArray[2].toString(2));
                }
            }
            if(highMask){
                const bitIsSet = (decodedPasswordArray[3] ^ decodedPasswordArray[0]) & highMask;
                if((bitIsSet && !bitShouldBeSet) || (!bitIsSet && bitShouldBeSet)){
                    // Flip bit at decodedPasswordArray[3]
                    console.log("Flipping bit pos 3 " + highMask.toString(2));
                    console.log(decodedPasswordArray[3].toString(2));
                    decodedPasswordArray[3] ^= highMask;
                    console.log(decodedPasswordArray[3].toString(2));
                }
            }
            
            
            fixChecksum(decodedPasswordArray);

            decodedPasswordElement.value = "[" + decodedPasswordArray.map(toHex).join(", ") + "]";
        }

        function updateSizeLabels() {
            const password = document.getElementById("password").value;
            const passwordArray = passwordStringTo8bitArray(password);
            document.getElementById("passSize").innerText = (passwordArray.length - 1); // password has a terminator character, so we subtract 1
            const decodedPassword = document.getElementById("decodedPassword").value;
            const decodedPasswordArray = convertHexStringToArray(decodedPassword);
            document.getElementById("decodeSize").innerText = decodedPasswordArray.length;
        }

        function updateFlagCheckboxes() {
            const decodedPassword = document.getElementById("decodedPassword").value;
            const decodedPasswordArray = convertHexStringToArray(decodedPassword);
            document.getElementById("bit5").checked = isBitSet(decodedPasswordArray, 0x20);
            document.getElementById("bit3").checked = isBitSet(decodedPasswordArray, 0x04);
            document.getElementById("bit2").checked = isBitSet(decodedPasswordArray, 0x02);
            document.getElementById("bit11").checked = isBitSet(decodedPasswordArray, 0x0400);
            document.getElementById("bit9").checked = isBitSet(decodedPasswordArray, 0x0100);
            document.getElementById("bit13").checked = isBitSet(decodedPasswordArray, 0x1000);
            document.getElementById("bit8").checked = isBitSet(decodedPasswordArray, 0x0080);
        }

        function extractParameters(decoded, bitCounts) {

            // Step 1: figure out how many bits are used in each payload byte (starting at decoded[2])
            const bitsUsedInByte = [];
            let bitsLeftInCurrentByte = 8;
            let byteNumber = 0; // 0 means decoded[2]

            for (const bitCount of bitCounts) {
                for (let i = 0; i < bitCount; i++) {
                    bitsUsedInByte[byteNumber] = (bitsUsedInByte[byteNumber] || 0) + 1;

                    bitsLeftInCurrentByte--;
                    if (bitsLeftInCurrentByte === 0) {
                        byteNumber++;
                        bitsLeftInCurrentByte = 8;
                    }
                }
            }

            // Step 2: traverse the bitstream in the final stored order and rebuild params
            const params = [];

            let currentIndex = 2; // decoded[2] is first packed byte
            let bitOffsetInUsedRegion = 0;

            for (const bitCount of bitCounts) {
                let value = 0;

                for (let i = 0; i < bitCount; i++) {
                    const used = bitsUsedInByte[currentIndex - 2] || 0;
                    const startBit = 8 - used; // where the "used region" begins (e.g. 4-bit => start at bit 4)

                    const bitPosition = startBit + bitOffsetInUsedRegion; // left -> right inside used region
                    const bit = (decoded[currentIndex] >>> bitPosition) & 1;

                    // original encoder consumed value LSB-first, so rebuild LSB-first
                    value |= (bit << i);

                    bitOffsetInUsedRegion++;
                    if (bitOffsetInUsedRegion === used) {
                        currentIndex++;
                        bitOffsetInUsedRegion = 0;
                    }
                }

                params.push(value);
            }

            return params;
        }

        const passwordTypeSelector = document.getElementById("passwordTypeSelector");
        const passwordParametersForm = document.getElementById("passwordParametersForm");
        const generatedPassword = document.getElementById("generatedPassword");
        const advancedToggle = document.getElementById("advancedToggle");
        const advancedSection = document.getElementById("advancedSection");

        function getMaxValue(bits) {
            return Math.pow(2, bits) - 1;
        }

        function buildPasswordForm(typeIndex) {
            const selected = passwordMap[typeIndex];
            if (!selected) {
                passwordParametersForm.innerHTML = "";
                return;
            }

            passwordParametersForm.innerHTML = "";
            selected.values.forEach((entry, index) => {
                const label = document.createElement("label");
                label.setAttribute("for", `entry${index}`);
                label.textContent = `${entry.description}:`;

                let input;
                if (entry.type === "team") {
                    input = document.createElement("select");
                    input.classList.add("teamInput");
                    populateTeamSelect(input);
                } else if (entry.type === "gameResult") {
                    input = document.createElement("select");
                    input.classList.add("victoryInput");
                    populateVictorySelect(input);
                } else {
                    input = document.createElement("input");
                    input.type = "number";
                    input.min = "0";
                    input.max = `${getMaxValue(entry.bits)}`;
                }

                input.id = `entry${index}`;
                input.value = entry.default;
                label.appendChild(input);
                passwordParametersForm.appendChild(label);
            });
        }

        function getSelectedPasswordEntry() {
            const selectedIndex = Number(passwordTypeSelector.value);
            return passwordMap[selectedIndex] || passwordMap[0];
        }

        function formatPasswordForDisplay(passwordString) {
            const cleaned = passwordString.replace(/\s+/g, "").slice(0, 60);
            const padded = cleaned.padEnd(60, "•");
            const groups = [];
            for (let i = 0; i < 12; i++) {
                groups.push(padded.slice(i * 5, i * 5 + 5));
            }

            return [
                groups.slice(0, 4).join(" "),
                groups.slice(4, 8).join(" "),
                groups.slice(8, 12).join(" ")
            ].join("\n");
        }

        function updateGeneratedPassword(passwordString) {
            generatedPassword.textContent = formatPasswordForDisplay(passwordString);
        }

        function generateInternationalEliminationPhasePassword() {
            const selected = getSelectedPasswordEntry();
            if (!selected) {
                return;
            }

            const passwordArray = selected.values.map((entry, index) => {
                const input = document.getElementById(`entry${index}`);
                const rawValue = input ? Number(input.value) : entry.default;
                const value = Number.isNaN(rawValue) ? entry.default : rawValue;
                return [entry.bits, value];
            });

            const passwordString = encodedValuesToPasswordString(genPassForDecodedPassword(bitPackValues(passwordArray)));
            updateGeneratedPassword(passwordString);
        }

        function initializePasswordSelector() {
            passwordMap.forEach((entry, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = `${entry.passwordFor}`;
                passwordTypeSelector.appendChild(option);
            });

            passwordTypeSelector.value = "0";
            buildPasswordForm(0);
            generateInternationalEliminationPhasePassword();
        }

        passwordTypeSelector.addEventListener("change", () => {
            buildPasswordForm(Number(passwordTypeSelector.value));
            generateInternationalEliminationPhasePassword();
        });

        advancedToggle.addEventListener("click", () => {
            const isVisible = advancedSection.classList.toggle("is-visible");
            advancedToggle.textContent = isVisible ? "Hide advanced" : "Show advanced";
            advancedToggle.setAttribute("aria-expanded", isVisible.toString());
        });

        initializePasswordSelector();

        runTests();
    </script>
</body>

</html>
